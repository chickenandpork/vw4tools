package org.smallfoot.vw4 ;

/** @file */

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Vector;
import javax.activation.DataSource;
import javax.activation.URLDataSource;
import javax.xml.XMLConstants;
import javax.xml.namespace.QName;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;
import gnu.getopt.Getopt;
import gnu.getopt.LongOpt;
import org.smallfoot.parser.ParserTee;
import org.smallfoot.parser.zone.AliShowZoneParser;
import org.smallfoot.parser.zone.Alias4Parser;
import org.smallfoot.parser.zone.BNAZoneParser;
import org.smallfoot.parser.zone.DeviceAliasParser;
import org.smallfoot.parser.zone.NicknameParser;
import org.smallfoot.parser.zone.ShowZoneParser;
import org.smallfoot.parser.zone.ZPAliasEntry;
import org.smallfoot.parser.zone.ZoneParser;
import org.smallfoot.vw4.VWImport;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


/* The following is conditionally permitted based on the mutually-exclusive choice at ./configure time.  --with-json= chooses exactly one of the following, causing one of the following comment blocks pairs to be butchered */
/* *@DO_JSON_JAVA_TRUE@/	import org.json.*;				/@DO_JSON_JAVA_TRUE@* */
/* *@DO_JSON_JACKSON_TRUE@/	import com.fasterxml.jackson.core.json.*;	/@DO_JSON_JACKSON_TRUE@* */
/* *@DO_JSON_JACKSON_TRUE@/	import com.fasterxml.jackson.core.*;		/@DO_JSON_JACKSON_TRUE@* */
/* *@DO_JSON_JACKSON_TRUE@/	import com.fasterxml.jackson.databind.*;	/@DO_JSON_JACKSON_TRUE@* */
/* *@DO_JSON_JACKSON_TRUE@/	import com.fasterxml.jackson.databind.jsonschema.*;	/@DO_JSON_JACKSON_TRUE@* */

/**
 * VirtualWisdom4ClientTool is a "Swiss Army Knife" of tools used when working with
 * VirtualWisdom4.  The existence of these tools is not a judgement on VirtualWisdom4's
 * proper Engineering; rather, an acceptance that a faster-response solution for the
 * longer-tail of the normal curve is often helpful swapping QA delay for reduced customer
 * friction.
 *
 * As you'd expect, there is no support for this.  If it breaks, you may choose to keep both
 * pieces :)
 *
 * Ad-Hoc content for this utility-stack may appear at http://fcfae.com/
 */
public class VirtualWisdom4ClientTool
{
    private org.w3c.dom.Document xmlDocument;		/**< eventually used to hold an XML document when converting XML<-->JSON<-->XML */

    /**
     * Class Constructor to create with an initial file to load.
     *
     * @param xmlFile File to load at start
     *
     * @see #load(String)
     */
    public VirtualWisdom4ClientTool(String xmlFile)
    {
        load(xmlFile);
    }

    /**
     * Class Constructor with no initial file.
     */
    public VirtualWisdom4ClientTool()
    {
    }

    /**
     * Open a file.
     *
     * This is actually a wrapper for the underlying file load
     *
     * @param filename file to load
     */
    protected void _load(String filename)
    throws java.lang.Exception
    {
        throw new java.lang.Exception ("unimplemented");
    }

    /**
     * Wrapper to just load the file, spitting out exceptions and stacks as they occur.
     *
     * @param filename file to load
     */
    public void load(String filename)
    {
        try
        {
            _load (filename);
        }
        catch (java.lang.Exception e)
        {
            e.printStackTrace();
        }
    }

    /**
     * Save the current XML Document to a new file.
     *
     * @param filename filename to save into
     */
    protected void _save(String filename)
    throws java.lang.Exception
    {
        throw new java.lang.Exception ("unimplemented");
    }

    /**
     * Wrapper to just save the file, spitting out exceptions and stacks as they occur.
     *
     * @param filename filename to save into
     */
    public void save (String filename)
    {
        try
        {
            _save (filename);
        }
        catch (java.lang.Exception e)
        {
            e.printStackTrace();
        }
    }


    /**
     * Produce an InputStream for the given uri in a way that corresponds to the url protocol
     *
     * @return InputStream ready to offer back the data
     * @param uri the file:// resource of a file, ie "file:///sample.csv"
     */
    protected java.io.InputStream openStream(String uri) throws java.io.FileNotFoundException, java.net.MalformedURLException, java.io.IOException
    {
        // http://www.roseindia.net/java/beginners/construct_file_name_path.shtml ?
        if (uri.toLowerCase().startsWith("file://"))
        {
            InputStream rr = new FileInputStream(uri.substring(7));
            return rr;
        }
        else   //if (uri.toLowerCase().startsWith("http://"))
        {
            DataSource ds = new URLDataSource(new java.net.URL(uri));

            /* documented above */
            if (true == new Boolean (System.getProperties().getProperty("debug.showURLOpener")))
                System.out.println("using discovered URL opener: DataSource open to "+uri);

            return ds.getInputStream();
        }
    }


    /**
     * Load a file from the resource given to a WWN/Nickname vector
     *
     * @return the number of things loaded (used to trigger obsessive retries to get around choking org.apache.commons.io.input.TeeInputStream )
     * @param url the file:// resource of a file, ie "file://sample.csv;wwn=1;nickname=2"
     * @param verbose if true, parser results will be shown to stdout
     */
    public ZoneParser loadFile(String url, boolean verbose)
    {
        String[] params = url.split(";");
        int colWWN=0;
        int colNickname=1;

        java.util.Properties prop = new java.util.Properties();

        for (int i = 1; i < params.length; i++)
        {
            String eq[] = params[i].split("=");
            if (eq.length > 1) prop.setProperty(eq[0].toLowerCase(),eq[1]);
        }

        java.io.InputStream is = null;
        try
        {
            is	= openStream(params[0]);
        }
        catch (Exception e)
        {
            /*
             * In the case of a bad URL, we could check to see if there's a missing protocol or whatnot,
             * but hey, why not just try to read it?  I could do a lot of work to accommodate
             * Windows/DOS only, but then some change to the OS might come along.  Simply trying to
             * read it as an exception-handler might be the most straight-forward path here.
             */
            java.io.File nf = new File(params[0]);
            if (nf.canRead())
                try
                {
                    is = new FileInputStream(nf);
                }
                catch (java.io.FileNotFoundException fnfe)
                {
                    /* OK, workaround failed, but this shouldn't happen after a canRead() */
                    if (verbose) System.out.println("Failure to open "+params[0]+": " + e.getMessage() + " was followed by a File Not Found exception trying to open "+nf.getAbsolutePath()+" as a workaround");
                    return null;
                }
            else
            {
                /* OK, workaround failed.  Wap wap waaaaap */
                if (verbose) System.out.println("Failure to open "+params[0]+": " + e.getMessage());
                return null;
            }
        }

        Vector<ZoneParser> zpl = new Vector();

        /* tried 2013-04-23 with 18 ParserTees feeding a NicknameParser, a AliShowZoneParser, and 16 Alias4Parsers */
        /* tried 2013-04-23 with 17 ParserTees feeding a NicknameParser, 2 AliShowZoneParser, and 14 Alias4Parsers */
        zpl.add( new NicknameParser(prop, false));
        zpl.add( new AliShowZoneParser(prop, false));
        zpl.add( new Alias4Parser(prop, false));

        zpl.add( new BNAZoneParser(prop, false));
        zpl.add( new DeviceAliasParser(prop, false));
        zpl.add( new ShowZoneParser(prop, false));

        try
        {
            for (ZoneParser zp:zpl)
                is = new ParserTee (is, zp);
        }
        catch (java.io.IOException ioe)
        {
            if (verbose) System.out.println("Failure to seam a pipe for parsing "+params[0]+": " + ioe.getMessage());
            return null;
        }

        /*
         * It would be more elegant to hold one of the ZoneParsers, and to cap it onto the end of
         * the ParserTee pipe, but there's a certain simplicity in merely draining the pipe herein
         * to cause the dupes ot all run.  It's a bit wasteful, but works, and makes the code
         * above lack any exceptions that can be difficult to explain.
         */
        BufferedReader br = new BufferedReader(new InputStreamReader(is));

        //read each line of text file
        try
        {
            while (-1 < br.read()) ;
        }
        catch (java.io.IOException ioe)
        {
            if (verbose) System.out.println("I/O Error: " + ioe.getMessage());
        }

        /*
         * OK, the entire pipe is drained, but we need to close it to signal that the stream ends
         * to all the Tees
         */
        //close the file
        try
        {
            br.close();
        }
        catch (java.io.IOException ioe)
        {
            if (verbose) System.out.println("I/O Error: " + ioe.getMessage());
        }

        /*
         * Now that it's closed, we may need to give some thread-time to each parser to get them
         * to finish parsing the stream
         */
        for (ZoneParser zp:zpl)
            try
            {
                if (java.lang.Thread.State.TERMINATED != zp.getState())
                    zp.join (10);

                for (int i = 10; i > 0 && java.lang.Thread.State.TERMINATED != zp.getState() ; i--)
                {
                    if (verbose) System.out.println("waiting for parser to drain: "+i+" "+zp.getClass().getName());
                    zp.join (100);
                }
            }
            catch (java.lang.InterruptedException ie) {}

        /*
         * Great, we have a closed stream, only read once, and we have Parsers all loaded up with content.
         *
         * Shall we tally-the-votes to see who wins?
         */

        ZoneParser winningzp = null;
        for (ZoneParser zp:zpl)
        {
            if (verbose)
                System.out.println("(vict) parsed " + zp.zoneSize() + " zones, " + zp.aliasSize() + " aliases via "+zp.getClass().getName().replaceAll(".*\\.",""));

            if (null == winningzp)
                winningzp = zp;
            else if (zp.aliasSize() > winningzp.aliasSize())
                winningzp = zp;
            else if (zp.zoneSize() > winningzp.zoneSize())
                winningzp = zp;
        }

        return winningzp;
    }


    /**
     * Convenience function to generate a pretty-printed JSON text string
     *
     * @param v VWImport object to markup
     * @return a pretty-printed JSON using ObjectWriter.withDefaultPrettyPrinter() or null if an exception occurs
     */
    public String prettyJSON(VWImport v)
    {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL);

        try
        {
            ObjectWriter ow = mapper.writer().withDefaultPrettyPrinter();
            return ow.writeValueAsString(v);
        }
        catch (JsonMappingException jme)
        {
            System.err.println("INTERNAL: A JsonMappingException has occurred on output; this needs to be resolved by VI Services.\nPlease communicate the error, and any input text used, as well as the version (0.9-1) to VI Services");
            return null;
        }
        catch (JsonProcessingException jpe)
        {
            System.err.println("INTERNAL: A JsonProcessingException has occurred on output; this needs to be resolved by VI Services.\nPlease communicate the error, and any input text used, as well as the version (0.9-1) to VI Services");
            return null;
        }

    }



    /**
     * Usage messages are useful to those of us with short memories as well (hey, I just need to add swap!)
     *
     * @param progname the name of the program (args[0]) to print on a usage message
     */
    void usage(String progname)
    {
        System.out.println("Usage: "+progname+" -V|--version|-H|--help");
        System.out.println("     : "+progname+" --read <filename>|--input <filename> | -r <filename> | -i <filename>");

        System.out.println("   ie: "+progname+" --read import.json");
        System.out.println("   ie: "+progname+" -r import.json");
    }


    /**
     * Main function, as you can tell.
     *
     * this function merely parses the command-line to dispatch actions to the meat of the meal above.
     * I'm using an actual GetOpt because, yes, I'm a UNIX/C hack, re-using 3-decades-old knowledge,
     * but this also preserves both extensibility and the ability to use longopts in scripts as a
     * way to self-document what the tool's doing.
     *
     * No real intelligence herein except the parse-and-redirect action.
     *
     * @param args as you'd expect, these are commandline arguments given when the jar is activated
     */
    public static void main(String args[])
    {
        VirtualWisdom4ClientTool m = new VirtualWisdom4ClientTool();
        VWImport vwimport = null;

        Vector<LongOpt> options = new Vector(20,2);

        /* Always always ALWAYS provide a quick reference and a version output */
        options.add(new LongOpt("help", LongOpt.NO_ARGUMENT, null, 'H'));
        options.add(new LongOpt("version", LongOpt.NO_ARGUMENT, null, 'V'));

        options.add(new LongOpt("read", LongOpt.REQUIRED_ARGUMENT, null, 'r'));
        options.add(new LongOpt("input", LongOpt.REQUIRED_ARGUMENT, null, 'i'));
        options.add(new LongOpt("nickname", LongOpt.REQUIRED_ARGUMENT, null, 'N'));
        options.add(new LongOpt("output", LongOpt.OPTIONAL_ARGUMENT, null, 'o'));

        options.add(new LongOpt("test", LongOpt.REQUIRED_ARGUMENT, null, 'T'));

        /* *@DO_GETOPTJAR_TRUE@/        org.smallfoot.getopt.GetOpt	g = new org.smallfoot.getopt.GetOpt("vw4tool", args, options);        /*@DO_GETOPTJAR_TRUE@ */
        /* *@DO_GETOPTJAR_FALSE@/       gnu.getopt.Getopt		g = new gnu.getopt.Getopt("vw4tool", args, "HV", options);        /@DO_GETOPTJAR_FALSE@* */


        int c;
        while ((c = g.getopt()) != -1)
        {
            switch(c)
            {
            case 'i':	/* fall-thru */
            case 'r':   // Read in a config file
            {
                com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                //mapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);

                try
                {
                    vwimport = mapper.readValue(new File(g.getOptarg()), VWImport.class);
                }
                catch (java.io.IOException ioe)
                {
                    System.out.println("IO Exception reading from "+g.getOptarg()+": "+ioe.getMessage());
                }
                //JsonParseException,
                //JsonMappingException
            }
            break;

            case 'N': /* input Nicknames using file://, ftp://, http:// via fibrechannel-parsers fcparsers.jar */
            {
                String f = g.getOptarg();
                ZoneParser p = null;

                for (int x = 3; (0 < x ) && (null == (p = m.loadFile(f, true))); x--)
                    System.out.println("retrying: reading "+f);
            }
            break;


            case 'o':   // Write a config file out
            {
                /*
                   XmlMapper mapper = new XmlMapper()
                   MyBean bean = new MyBean();

                   String xml = mapper.writeValueAsString(bean);
                   // System.out.println(mapper.writerWithDefaultPrettyPrinter().writeValueAsString(user));

                   // we get something like "<MyBean><property>value</property>....</MyBean>"
                   MyBean beanFromXml = mapper.readValue(xml, MyBean.class);
                 */


                System.err.println("NOTE: writing");
                try
                {
                    if ( (null != g.getOptarg()) && (g.getOptarg().equalsIgnoreCase("schema.json")) )
                    {
                        com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                        JsonSchema schema = mapper.generateJsonSchema(vwimport.getClass());


                        //ObjectWriter ow = mapper.writer().withDefaultPrettyPrinter();
                        /*
                        ObjectWriter ow = mapper.writer(new com.fasterxml.jackson.core.util.DefaultPrettyPrinter());
                        	System.out.println(ow.writeValueAsString(schema)); */
                        System.out.println("blah" + m.prettyJSON(vwimport)+"blah");

                        //System.out.println(mapper.writer(new com.fasterxml.jackson.core.util.DefaultPrettyPrinter()).writeValueAsString(schema));
                    }
                    else if (null == vwimport)
                    {
                        System.err.println("ERROR: no content loaded");
                        return;
                    }
                    else if (
                        ( null == g.getOptarg() ) ||
                        (g.getOptarg().equalsIgnoreCase("")) ||
                        (g.getOptarg().equalsIgnoreCase("-"))  )
                    {
                        System.err.println("NOTE: writing to stdout");
                        String o = (new com.fasterxml.jackson.databind.ObjectMapper()).writerWithDefaultPrettyPrinter().writeValueAsString(vwimport);
                        System.out.println(o);
                    }
                    else
                    {
                        com.fasterxml.jackson.databind.ObjectMapper mapper = new com.fasterxml.jackson.databind.ObjectMapper();
                        try
                        {
                            mapper.writeValue(new File(g.getOptarg()), vwimport);
                        }
                        catch (java.io.IOException ioe)
                        {
                            System.out.println("IO Exception writing to "+g.getOptarg()+": "+ioe.getMessage());
                        }
                        //JsonParseException,
                        //JsonMappingException
                    }
                }
                catch (JsonMappingException jme)
                {
                    System.err.println("INTERNAL: A JsonMappingException has occurred on output; this needs to be resolved by VI Services.\nPlease communicate the error, and any input text used, as well as the version (0.9-1) to VI Services");
                }
                catch (JsonProcessingException jpe)
                {
                    System.err.println("INTERNAL: A JsonProcessingException has occurred on output; this needs to be resolved by VI Services.\nPlease communicate the error, and any input text used, as well as the version (0.9-1) to VI Services");
                }
            }
            break;

            /*
             * Testcase generation -- internal use only, used to create bogus internal content to test output format
             */
            case 'T':   // create internal content for export
            {
                if (g.getOptarg().equalsIgnoreCase ("sample01"))
                {
                    vwimport = new VWImport();
                    VWImport.Entity e = new VWImport.Entity();
                    e.description = "sample01 test entity";
                    e.edit_type = VWImport.Edit_Type.add;
                    e.type = "application";
                    e.name = "sample01_itl";
                    e.itl_patterns = new Vector<VWImport.ITLPattern>();
                    VWImport.ITLPattern i = new VWImport.ITLPattern();
                    i.edit_type = VWImport.Edit_Type.add;
                    i.initiator = "1000002590123456";
                    e.itl_patterns.add(i);
                    vwimport.entities().add(e);
                    System.err.println(vwimport.entities().size() + " entities defined");
                }
                else
                {
                    System.err.println("testcase generation: Testcase \""+g.getOptarg()+"\" is not understood");
                    System.err.println("testcases include: sample01");
                    return;
                }
            }
            break;

            /*
             * Follows is the "house-keeping": versions, usage, and the catch-all for bad options.
             */
            case 'V':   // print the version and quit
            {
                System.out.println(g.consistentVersion("@VERSION@-@BUILDID@")+"\n");
                return;
            }

            default:
            case '?':
            case 'H':
                m.usage(g.progname());
                break;
            }
        }
    }
}
