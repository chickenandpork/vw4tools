<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.7">
  <compounddef id="cmdopt" kind="page">
    <compoundname>cmdopt</compoundname>
    <title>Commandline Options</title>
    <detaileddescription>
<para><variablelist>
<varlistentry><term><anchor id="cmdopt_1_cmdopt000001"/>Global <ref refid="classorg_1_1smallfoot_1_1vw4_1_1VirtualWisdom4ClientTool_1a75988cf84fc6ee7a2ebff36e363021aa" kindref="member">VirtualWisdom4ClientTool.main</ref>  (String args[])</term></varlistentry>
<listitem><para>-H|<ndash/>help Show a simple help screen as a reminder of options which are understood by the application </para><para><programlisting><codeline><highlight class="normal">java<sp/>-jar<sp/>vw4tools.jar<sp/>--help<sp/></highlight></codeline>
</programlisting></para><para>-V|<ndash/>version Show the current release version for reference </para><para><programlisting><codeline><highlight class="normal">java<sp/>-jar<sp/>vw4tools.jar<sp/>--version</highlight></codeline>
<codeline><highlight class="normal"><sp/>1.0-9<sp/></highlight></codeline>
</programlisting></para><para>-n|<ndash/>nicknameout={file} Output nicknames from internal store </para><para>-o|<ndash/>output={file} Output nicknames from internal store <ndash/>nicknameout and <ndash/>output are currently functionally identical; they both cause the internal nickname/entity base to be written out as JSON with the exception of a few &quot;magic&quot; filenames:</para><para>1. <bold>schema.json</bold> will cause the current schema to be written </para><para>2. <bold>orderedtuples.csv</bold> will cause an OrderedTuples.csv file to be written, suitable for post-processing via <ref refid="csv-to-json_8awk" kindref="compound">csv-to-json.awk</ref> but allowing a user to more easily edit CSV for fine-tuning </para><para>3. <bold>orphanentities.csv</bold> will cause a CSV to be written listing all orphan entities. An &quot;Orphan Entity&quot; is an entity lacking a parent entity, such as an &quot;HBA Port&quot; without a &quot;host&quot; parent, or a &quot;iomodule&quot; without a parent &quot;storagearray&quot; entity.</para><para>All other filename patterns will result in a JSON-formatted file</para><para>-N|<ndash/>nickname={file/uri} Import nicknames by parsing a text stream from various sources </para><para><programlisting><codeline><highlight class="normal">java<sp/>-jar<sp/>vw4tools.jar<sp/>--nickname=switch44.zoneshow</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Parse<sp/>results<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>AliShowZoneParser:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Zones:<sp/>44</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Aliases:<sp/>112<sp/>(names<sp/>with<sp/>one<sp/>or<sp/>more<sp/>WWPNs)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Aliases:<sp/>136<sp/>(name/WWPN<sp/>tuples)<sp/></highlight></codeline>
</programlisting> In this example, a zone file was parsed by the AliShowZoneParser resulting in 112 nicknames; due to duplicate nicknames, there are actually 136 unique WWPN/alias tuples, which means that (136-112) 24 of the WWPNs have the same alias as other WWPNs</para><para>-i|<ndash/>input import an existing JSON file for later editing </para><para>-r|<ndash/>read import an existing JSON file for later editing </para><para><programlisting><codeline><highlight class="normal">java<sp/>-jar<sp/>vw4tools.jar<sp/>--read<sp/>working.json<sp/></highlight></codeline>
</programlisting></para><para>-R|<ndash/>remove Parse nicknames for removal from the internal nickname list </para><para>-R|<ndash/>removenicknames Parse nicknames for removal from the internal nickname list</para><para>-t|<ndash/>target set a target version for JSON output. Defaults to latest supported. A value of 4.0.1 is converted to 40.1 internally due to float comparison and expected changed every bump of major/minor version</para><para>-!|<ndash/>report Summarize the current status of the internal nicknaes and pattern/collation coverage </para><para><programlisting><codeline><highlight class="normal">java<sp/>-jar<sp/>vw4tools.jar<sp/>--nickname=switch44.zoneshow<sp/><sp/>--report</highlight></codeline>
<codeline><highlight class="normal">(vw4tools)<sp/>parsed<sp/>0<sp/>zones,<sp/>2<sp/>aliases<sp/>via<sp/>Alias4Parser</highlight></codeline>
<codeline><highlight class="normal">vw4tools<sp/>1.0-9</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>5<sp/>total<sp/>entities</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>4<sp/>leaf<sp/>nodes</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>2<sp/>orphans</highlight></codeline>
<codeline><highlight class="normal">50.00<sp/>%<sp/>coverage<sp/></highlight></codeline>
</programlisting> </para><para>-P|<ndash/>pattern= is used to provide an &quot;aggregating pattern&quot; to collect Orphan Entities into a container. An &quot;Orphan Entity&quot; is an entity which is not part of a larger device: an HBA not assigned to a host, or a FA not assigned to a storage array. Aggregating Patterns are evaluated immediately, so their order amidst other command options to import or remove entities is important. </para><para>-p|<ndash/>checkpattern= is used to test an &quot;aggregating pattern&quot; against a certain nickname/alias. Although Aggregating Patterns are evaluated immediately, they&apos;re stored for testing as well, so even though we&apos;re giving a test alias after the pattern, it&apos;ll evaluate all loaded patterns against the alias: </para><para><programlisting><codeline><highlight class="normal"><sp/>java<sp/>-jar<sp/>vw4tools.jar<sp/>--pattern=</highlight><highlight class="stringliteral">&quot;([^-]+)-[^-]+$&quot;</highlight><highlight class="normal"><sp/>--checkpattern=NetApp-123456<sp/>--checkpattern=UberServer_44_HBA0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;NetApp-123456&quot;</highlight><highlight class="normal"><sp/>--&gt;<sp/></highlight><highlight class="stringliteral">&quot;NetApp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;UberServer_44_HBA0&quot;</highlight><highlight class="normal"><sp/>--&gt;<sp/></highlight><highlight class="stringliteral">&quot;UberServer_44_HBA0&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
</programlisting> </para><para>in this example, the one pattern it tested against a new alias when the <ndash/>checkpattern is encountered; if there were two patterns, each pattern would be tried to the checkpattern sample when seen:</para><para><programlisting><codeline><highlight class="normal"><sp/>java<sp/>-jar<sp/>vw4tools.jar<sp/>--pattern=</highlight><highlight class="stringliteral">&quot;([^-]+)-[^-]+$&quot;</highlight><highlight class="normal"><sp/>--pattern=</highlight><highlight class="stringliteral">&quot;^(.*)_hba(\d+)$&quot;</highlight><highlight class="normal"><sp/>--checkpattern=NetApp-123456<sp/>--checkpattern=UberServer_44_hba0</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;NetApp-123456&quot;</highlight><highlight class="normal"><sp/>--&gt;<sp/></highlight><highlight class="stringliteral">&quot;NetApp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;NetApp-123456&quot;</highlight><highlight class="normal"><sp/>--&gt;<sp/></highlight><highlight class="stringliteral">&quot;NetApp-123456&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;UberServer_44_HBA0&quot;</highlight><highlight class="normal"><sp/>--&gt;<sp/></highlight><highlight class="stringliteral">&quot;UberServer_44_hba0&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="stringliteral">&quot;UberServer_44_HBA0&quot;</highlight><highlight class="normal"><sp/>--&gt;<sp/></highlight><highlight class="stringliteral">&quot;UberServer_44&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
</programlisting> </para><para>in this example, two patterns ( &quot;([^-]+)-[^-]+$&quot; and &quot;^(.*)_hba(\d+)$&quot; ) are loaded; when &quot;NetApp-123456&quot; is given as a checkpattern, each is tried in turn, so we see that &quot;([^-]+)-[^-]+$&quot; converts &quot;NetApp-123456&quot; to &quot;NetApp&quot;, which means a bunch of devices &quot;NetApp-123456&quot;, &quot;NetApp-123457&quot;, &quot;NetApp-ABCDEF&quot; would be child entities of a larger entity &quot;NetApp&quot;. In essence, all the NetApp-* are collected into the same contailer called &quot;NetApp&quot;. Similarly, &quot;([^-]+)-[^-]+$&quot; and &quot;^(.*)_hba(\d+)$&quot; are tested against &quot;UberServer_44_hba0&quot; when the checkpattern is given, and we can see that &quot;([^-]+)-[^-]+$&quot; makes no difference to the value, but &quot;^(.*)_hba(\d+)$&quot; has the desired effect of chopping off the &quot;_hba#&quot; portion. </para></listitem>
</variablelist>
</para>    </detaileddescription>
  </compounddef>
</doxygen>
